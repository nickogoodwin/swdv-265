function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { Animated, Platform, StyleSheet, View } from 'react-native';
import { Gesture, GestureDetector, ScrollView } from 'react-native-gesture-handler';
import { PdfView } from './PdfView';
const AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);

/**
 * Get a `Promise` that will resolve when the next frame can be rendered.
 */
function sleepToNextFrame() {
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
/**
 * Compute base dimensions at which the pdf should be displayed.
 */


function getViewDims(pdfSize, viewSize) {
  let viewWidth = viewSize.width;

  if (pdfSize.width > 0 && pdfSize.height > pdfSize.width && viewSize.height > viewWidth) {
    // Portrait page on portrait device, shrink to fit.
    viewWidth = Math.min(viewWidth, pdfSize.width * viewSize.height / pdfSize.height);
  }

  let viewHeight = viewSize.height;

  if (pdfSize.width > 0) {
    viewHeight = pdfSize.height * viewWidth / pdfSize.width;
  }

  return {
    viewWidth,
    viewHeight
  };
}
/**
 * Bind an animated value for sync reads.
 */


function useSyncAnimatedXY() {
  const varXY = useRef({
    animated: new Animated.ValueXY({
      x: 0,
      y: 0
    }),
    static: {
      x: 0,
      y: 0
    }
  }).current; // Enable sync read of animated variable.

  useEffect(() => {
    const {
      animated
    } = varXY;
    const handle = animated.addListener(value => {
      varXY.static = value;
    });
    return () => {
      animated.removeListener(handle);
    };
  }, [varXY]);
  return varXY;
}

function useZoomGesture(pdfSize, viewSize, maxScale, hScrollRef, vScrollRef, onZoomIn, onZoomReset) {
  // Limits.
  const minScale = 1;
  const overshoot = 0.1;
  const hardMinScale = minScale * (1 - overshoot);
  const hardMaxScale = maxScale * (1 + overshoot);
  const [isZoomed, setIsZoomed] = useState(false);
  const gestureRef = useRef(); // Resolution to render.

  const containerScale = useRef({
    animated: new Animated.Value(1),
    static: 1
  }).current;
  const pinchScale = useRef(new Animated.Value(1)).current; // Current scroll position.

  const contentOffset = useSyncAnimatedXY(); // Centering buffers.

  const bufferSize = useRef(new Animated.ValueXY({
    x: 0,
    y: 0
  })).current;
  useEffect(() => {
    const {
      viewWidth,
      viewHeight
    } = getViewDims(pdfSize, viewSize);
    const width = Math.max((viewSize.width - containerScale.static * viewWidth) / 2, 0);
    const height = Math.max(viewSize.height - containerScale.static * viewHeight, 0);
    bufferSize.setValue({
      x: width,
      y: height
    });
  }, [bufferSize, containerScale, pdfSize, viewSize]); // Origin point of pinch gesture.

  const focalPoint = useSyncAnimatedXY();
  useEffect(() => {
    focalPoint.animated.setValue({
      x: viewSize.width / 2,
      y: viewSize.height / 2
    });
  }, [focalPoint, viewSize]); // Pixel interpolation scale. Input driver `pinchScale` is shaped to allow
  // some bounce past min/max thresholds.
  // TODO: Is it possible to use easing instead of clamp? Or maybe more
  // points on in/out range?

  const scale = useRef(Animated.divide(Animated.multiply(pinchScale, containerScale.animated).interpolate({
    inputRange: [minScale * 0.5, minScale, maxScale, maxScale * 1.5],
    outputRange: [hardMinScale, minScale, maxScale, hardMaxScale],
    extrapolate: 'clamp'
  }), containerScale.animated)).current;
  const gestureHandler = useMemo(() => {
    return Gesture.Pinch().withRef(gestureRef).onStart(e => focalPoint.animated.setValue({
      x: e.focalX,
      y: e.focalY
    })).onUpdate(e => pinchScale.setValue(e.scale)).onEnd(e => {
      // Spring back to scale bounds, if gesture overshot.
      const targetScale = Math.max(minScale, Math.min(maxScale, e.scale * containerScale.static));
      Animated.timing(pinchScale, {
        duration: 200,
        toValue: targetScale / containerScale.static,
        useNativeDriver: false
      }).start(async () => {
        const {
          viewWidth,
          viewHeight
        } = getViewDims(pdfSize, viewSize);
        const prevScale = containerScale.static;
        const prevBufferX = Math.max((viewSize.width - prevScale * viewWidth) / 2, 0); // Apply pinch scaling (pixel interpolation) to container (actual
        // render quality).

        containerScale.animated.setValue(targetScale);
        containerScale.static = targetScale;
        pinchScale.setValue(1);
        bufferSize.setValue({
          x: Math.max((viewSize.width - targetScale * viewWidth) / 2, 0),
          y: Math.max(viewSize.height - targetScale * viewHeight, 0)
        }); // Send zoom events.

        setIsZoomed(prevIsZoomed => {
          if (prevIsZoomed && targetScale <= 1) {
            if (Platform.OS === 'android') {
              var _hScrollRef$current;

              // Zoom complete, reset horizontal scroll. Needed for Android.
              (_hScrollRef$current = hScrollRef.current) === null || _hScrollRef$current === void 0 ? void 0 : _hScrollRef$current.scrollTo({
                x: 0,
                y: 0,
                animated: true
              });
            }

            if (onZoomReset != null) {
              onZoomReset();
            }
          } else if (!prevIsZoomed && targetScale > 1) {
            if (onZoomIn != null) {
              onZoomIn();
            }
          }

          return targetScale > 1;
        });

        if (targetScale > 1) {
          var _hScrollRef$current2, _vScrollRef$current;

          // Adjust scroll views to apply scaling in correct location.
          const targetX = targetScale / prevScale * (contentOffset.static.x - prevBufferX + focalPoint.static.x) - focalPoint.static.x;
          const targetY = targetScale / prevScale * (contentOffset.static.y + focalPoint.static.y) - focalPoint.static.y;
          await sleepToNextFrame();
          (_hScrollRef$current2 = hScrollRef.current) === null || _hScrollRef$current2 === void 0 ? void 0 : _hScrollRef$current2.scrollTo({
            x: targetX,
            animated: false
          });
          (_vScrollRef$current = vScrollRef.current) === null || _vScrollRef$current === void 0 ? void 0 : _vScrollRef$current.scrollTo({
            y: targetY,
            animated: false
          });
        }
      });
    });
  }, [bufferSize, containerScale, contentOffset, focalPoint, hScrollRef, gestureRef, maxScale, onZoomIn, onZoomReset, pdfSize, pinchScale, setIsZoomed, vScrollRef, viewSize]);
  const zoomStyle = useMemo(() => {
    const {
      viewWidth,
      viewHeight
    } = getViewDims(pdfSize, viewSize);
    const pdfViewWidth = Animated.multiply(containerScale.animated, viewWidth);
    const centerRatioX = Animated.divide(Animated.add(Animated.subtract(contentOffset.animated.x, bufferSize.x), focalPoint.animated.x), pdfViewWidth);
    const translateX = Animated.multiply(Animated.multiply(pdfViewWidth, Animated.subtract(scale, 1)), Animated.subtract(0.5, centerRatioX));
    const pdfViewHeight = Animated.multiply(containerScale.animated, viewHeight);
    const centerRatioY = Animated.divide(Animated.add(contentOffset.animated.y, focalPoint.animated.y), pdfViewHeight);
    const translateY = Animated.multiply(Animated.multiply(pdfViewHeight, Animated.subtract(scale, 1)), Animated.subtract(0.5, centerRatioY)); // Allow height to be manged by native pdf component.

    return {
      transform: [{
        translateX
      }, {
        translateY
      }, {
        scale
      }],
      width: pdfViewWidth
    };
  }, [bufferSize, contentOffset, containerScale, focalPoint, pdfSize, scale, viewSize]);
  return {
    bufferSize,
    contentOffset,
    gestureHandler,
    gestureRef,
    isZoomed,
    zoomStyle
  };
}
/**
 * PdfView with pinch zoom support.
 */


export function ZoomPdfView(props) {
  const {
    maximumZoom,
    onLoadComplete,
    onZoomIn,
    onZoomReset,
    refreshControl,
    renderComponent,
    ...pdfViewProps
  } = props;
  const [pdfSize, setPdfSize] = useState({
    width: -1,
    height: -1
  });
  const [viewSize, setViewSize] = useState({
    width: 1,
    height: 1
  });
  const hScrollRef = useRef(null);
  const vScrollRef = useRef(null);
  const RenderComponent = renderComponent ?? PdfView;
  const {
    bufferSize,
    contentOffset,
    gestureHandler,
    gestureRef,
    isZoomed,
    zoomStyle
  } = useZoomGesture(pdfSize, viewSize, maximumZoom ?? 2, hScrollRef, vScrollRef, onZoomIn, onZoomReset); // Combine `onLoadComplete` callback from props with logic required
  // by `ZoomPdfView`.

  const localOnLoadComplete = useCallback(e => {
    onLoadComplete === null || onLoadComplete === void 0 ? void 0 : onLoadComplete(e);
    const next = {
      width: e.width,
      height: e.height
    };
    setPdfSize(prev => prev.width === next.width && prev.height === next.height ? prev : next);
  }, [onLoadComplete, setPdfSize]); // Determine device orientation and (useable) screen ratio.

  const onViewLayout = useCallback(_ref => {
    let {
      nativeEvent
    } = _ref;
    const next = {
      width: nativeEvent.layout.width,
      height: nativeEvent.layout.height
    };
    setViewSize(prev => prev.width === next.width && prev.height === next.height ? prev : next);
  }, [setViewSize]); // `waitFor` required on Android, otherwise ScrollView overrides
  // pinch detection.
  // Horizontal `scrollEnabled` only when zoomed prevents conflict with
  // swipe between pages.

  return /*#__PURE__*/React.createElement(GestureDetector, {
    gesture: gestureHandler
  }, /*#__PURE__*/React.createElement(View, {
    style: Styles.container,
    onLayout: onViewLayout
  }, /*#__PURE__*/React.createElement(AnimatedScrollView, {
    horizontal: true,
    onScroll: Animated.event([{
      nativeEvent: {
        contentOffset: {
          x: contentOffset.animated.x
        }
      }
    }], {
      useNativeDriver: false
    }),
    ref: hScrollRef,
    scrollEnabled: isZoomed,
    scrollEventThrottle: 50,
    waitFor: Platform.select({
      android: gestureRef
    })
  }, /*#__PURE__*/React.createElement(AnimatedScrollView, {
    onScroll: Animated.event([{
      nativeEvent: {
        contentOffset: {
          y: contentOffset.animated.y
        }
      }
    }], {
      useNativeDriver: false
    }),
    ref: vScrollRef,
    refreshControl: refreshControl,
    scrollEventThrottle: 50,
    waitFor: Platform.select({
      android: gestureRef
    })
  }, /*#__PURE__*/React.createElement(View, {
    style: Styles.row
  }, /*#__PURE__*/React.createElement(Animated.View, {
    style: {
      width: bufferSize.x
    }
  }), /*#__PURE__*/React.createElement(Animated.View, {
    style: zoomStyle
  }, /*#__PURE__*/React.createElement(RenderComponent, _extends({}, pdfViewProps, {
    onLoadComplete: localOnLoadComplete
  }))), /*#__PURE__*/React.createElement(Animated.View, {
    style: {
      width: bufferSize.x
    }
  })), /*#__PURE__*/React.createElement(Animated.View, {
    style: {
      height: bufferSize.y
    }
  })))));
}
const Styles = StyleSheet.create({
  container: {
    flex: 1
  },
  row: {
    flexDirection: 'row'
  }
});
//# sourceMappingURL=ZoomPdfView.js.map