"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZoomPdfView = ZoomPdfView;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _PdfView = require("./PdfView");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const AnimatedScrollView = _reactNative.Animated.createAnimatedComponent(_reactNativeGestureHandler.ScrollView);

/**
 * Get a `Promise` that will resolve when the next frame can be rendered.
 */
function sleepToNextFrame() {
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
/**
 * Compute base dimensions at which the pdf should be displayed.
 */


function getViewDims(pdfSize, viewSize) {
  let viewWidth = viewSize.width;

  if (pdfSize.width > 0 && pdfSize.height > pdfSize.width && viewSize.height > viewWidth) {
    // Portrait page on portrait device, shrink to fit.
    viewWidth = Math.min(viewWidth, pdfSize.width * viewSize.height / pdfSize.height);
  }

  let viewHeight = viewSize.height;

  if (pdfSize.width > 0) {
    viewHeight = pdfSize.height * viewWidth / pdfSize.width;
  }

  return {
    viewWidth,
    viewHeight
  };
}
/**
 * Bind an animated value for sync reads.
 */


function useSyncAnimatedXY() {
  const varXY = (0, _react.useRef)({
    animated: new _reactNative.Animated.ValueXY({
      x: 0,
      y: 0
    }),
    static: {
      x: 0,
      y: 0
    }
  }).current; // Enable sync read of animated variable.

  (0, _react.useEffect)(() => {
    const {
      animated
    } = varXY;
    const handle = animated.addListener(value => {
      varXY.static = value;
    });
    return () => {
      animated.removeListener(handle);
    };
  }, [varXY]);
  return varXY;
}

function useZoomGesture(pdfSize, viewSize, maxScale, hScrollRef, vScrollRef, onZoomIn, onZoomReset) {
  // Limits.
  const minScale = 1;
  const overshoot = 0.1;
  const hardMinScale = minScale * (1 - overshoot);
  const hardMaxScale = maxScale * (1 + overshoot);
  const [isZoomed, setIsZoomed] = (0, _react.useState)(false);
  const gestureRef = (0, _react.useRef)(); // Resolution to render.

  const containerScale = (0, _react.useRef)({
    animated: new _reactNative.Animated.Value(1),
    static: 1
  }).current;
  const pinchScale = (0, _react.useRef)(new _reactNative.Animated.Value(1)).current; // Current scroll position.

  const contentOffset = useSyncAnimatedXY(); // Centering buffers.

  const bufferSize = (0, _react.useRef)(new _reactNative.Animated.ValueXY({
    x: 0,
    y: 0
  })).current;
  (0, _react.useEffect)(() => {
    const {
      viewWidth,
      viewHeight
    } = getViewDims(pdfSize, viewSize);
    const width = Math.max((viewSize.width - containerScale.static * viewWidth) / 2, 0);
    const height = Math.max(viewSize.height - containerScale.static * viewHeight, 0);
    bufferSize.setValue({
      x: width,
      y: height
    });
  }, [bufferSize, containerScale, pdfSize, viewSize]); // Origin point of pinch gesture.

  const focalPoint = useSyncAnimatedXY();
  (0, _react.useEffect)(() => {
    focalPoint.animated.setValue({
      x: viewSize.width / 2,
      y: viewSize.height / 2
    });
  }, [focalPoint, viewSize]); // Pixel interpolation scale. Input driver `pinchScale` is shaped to allow
  // some bounce past min/max thresholds.
  // TODO: Is it possible to use easing instead of clamp? Or maybe more
  // points on in/out range?

  const scale = (0, _react.useRef)(_reactNative.Animated.divide(_reactNative.Animated.multiply(pinchScale, containerScale.animated).interpolate({
    inputRange: [minScale * 0.5, minScale, maxScale, maxScale * 1.5],
    outputRange: [hardMinScale, minScale, maxScale, hardMaxScale],
    extrapolate: 'clamp'
  }), containerScale.animated)).current;
  const gestureHandler = (0, _react.useMemo)(() => {
    return _reactNativeGestureHandler.Gesture.Pinch().withRef(gestureRef).onStart(e => focalPoint.animated.setValue({
      x: e.focalX,
      y: e.focalY
    })).onUpdate(e => pinchScale.setValue(e.scale)).onEnd(e => {
      // Spring back to scale bounds, if gesture overshot.
      const targetScale = Math.max(minScale, Math.min(maxScale, e.scale * containerScale.static));

      _reactNative.Animated.timing(pinchScale, {
        duration: 200,
        toValue: targetScale / containerScale.static,
        useNativeDriver: false
      }).start(async () => {
        const {
          viewWidth,
          viewHeight
        } = getViewDims(pdfSize, viewSize);
        const prevScale = containerScale.static;
        const prevBufferX = Math.max((viewSize.width - prevScale * viewWidth) / 2, 0); // Apply pinch scaling (pixel interpolation) to container (actual
        // render quality).

        containerScale.animated.setValue(targetScale);
        containerScale.static = targetScale;
        pinchScale.setValue(1);
        bufferSize.setValue({
          x: Math.max((viewSize.width - targetScale * viewWidth) / 2, 0),
          y: Math.max(viewSize.height - targetScale * viewHeight, 0)
        }); // Send zoom events.

        setIsZoomed(prevIsZoomed => {
          if (prevIsZoomed && targetScale <= 1) {
            if (_reactNative.Platform.OS === 'android') {
              var _hScrollRef$current;

              // Zoom complete, reset horizontal scroll. Needed for Android.
              (_hScrollRef$current = hScrollRef.current) === null || _hScrollRef$current === void 0 ? void 0 : _hScrollRef$current.scrollTo({
                x: 0,
                y: 0,
                animated: true
              });
            }

            if (onZoomReset != null) {
              onZoomReset();
            }
          } else if (!prevIsZoomed && targetScale > 1) {
            if (onZoomIn != null) {
              onZoomIn();
            }
          }

          return targetScale > 1;
        });

        if (targetScale > 1) {
          var _hScrollRef$current2, _vScrollRef$current;

          // Adjust scroll views to apply scaling in correct location.
          const targetX = targetScale / prevScale * (contentOffset.static.x - prevBufferX + focalPoint.static.x) - focalPoint.static.x;
          const targetY = targetScale / prevScale * (contentOffset.static.y + focalPoint.static.y) - focalPoint.static.y;
          await sleepToNextFrame();
          (_hScrollRef$current2 = hScrollRef.current) === null || _hScrollRef$current2 === void 0 ? void 0 : _hScrollRef$current2.scrollTo({
            x: targetX,
            animated: false
          });
          (_vScrollRef$current = vScrollRef.current) === null || _vScrollRef$current === void 0 ? void 0 : _vScrollRef$current.scrollTo({
            y: targetY,
            animated: false
          });
        }
      });
    });
  }, [bufferSize, containerScale, contentOffset, focalPoint, hScrollRef, gestureRef, maxScale, onZoomIn, onZoomReset, pdfSize, pinchScale, setIsZoomed, vScrollRef, viewSize]);
  const zoomStyle = (0, _react.useMemo)(() => {
    const {
      viewWidth,
      viewHeight
    } = getViewDims(pdfSize, viewSize);

    const pdfViewWidth = _reactNative.Animated.multiply(containerScale.animated, viewWidth);

    const centerRatioX = _reactNative.Animated.divide(_reactNative.Animated.add(_reactNative.Animated.subtract(contentOffset.animated.x, bufferSize.x), focalPoint.animated.x), pdfViewWidth);

    const translateX = _reactNative.Animated.multiply(_reactNative.Animated.multiply(pdfViewWidth, _reactNative.Animated.subtract(scale, 1)), _reactNative.Animated.subtract(0.5, centerRatioX));

    const pdfViewHeight = _reactNative.Animated.multiply(containerScale.animated, viewHeight);

    const centerRatioY = _reactNative.Animated.divide(_reactNative.Animated.add(contentOffset.animated.y, focalPoint.animated.y), pdfViewHeight);

    const translateY = _reactNative.Animated.multiply(_reactNative.Animated.multiply(pdfViewHeight, _reactNative.Animated.subtract(scale, 1)), _reactNative.Animated.subtract(0.5, centerRatioY)); // Allow height to be manged by native pdf component.


    return {
      transform: [{
        translateX
      }, {
        translateY
      }, {
        scale
      }],
      width: pdfViewWidth
    };
  }, [bufferSize, contentOffset, containerScale, focalPoint, pdfSize, scale, viewSize]);
  return {
    bufferSize,
    contentOffset,
    gestureHandler,
    gestureRef,
    isZoomed,
    zoomStyle
  };
}
/**
 * PdfView with pinch zoom support.
 */


function ZoomPdfView(props) {
  const {
    maximumZoom,
    onLoadComplete,
    onZoomIn,
    onZoomReset,
    refreshControl,
    renderComponent,
    ...pdfViewProps
  } = props;
  const [pdfSize, setPdfSize] = (0, _react.useState)({
    width: -1,
    height: -1
  });
  const [viewSize, setViewSize] = (0, _react.useState)({
    width: 1,
    height: 1
  });
  const hScrollRef = (0, _react.useRef)(null);
  const vScrollRef = (0, _react.useRef)(null);
  const RenderComponent = renderComponent ?? _PdfView.PdfView;
  const {
    bufferSize,
    contentOffset,
    gestureHandler,
    gestureRef,
    isZoomed,
    zoomStyle
  } = useZoomGesture(pdfSize, viewSize, maximumZoom ?? 2, hScrollRef, vScrollRef, onZoomIn, onZoomReset); // Combine `onLoadComplete` callback from props with logic required
  // by `ZoomPdfView`.

  const localOnLoadComplete = (0, _react.useCallback)(e => {
    onLoadComplete === null || onLoadComplete === void 0 ? void 0 : onLoadComplete(e);
    const next = {
      width: e.width,
      height: e.height
    };
    setPdfSize(prev => prev.width === next.width && prev.height === next.height ? prev : next);
  }, [onLoadComplete, setPdfSize]); // Determine device orientation and (useable) screen ratio.

  const onViewLayout = (0, _react.useCallback)(_ref => {
    let {
      nativeEvent
    } = _ref;
    const next = {
      width: nativeEvent.layout.width,
      height: nativeEvent.layout.height
    };
    setViewSize(prev => prev.width === next.width && prev.height === next.height ? prev : next);
  }, [setViewSize]); // `waitFor` required on Android, otherwise ScrollView overrides
  // pinch detection.
  // Horizontal `scrollEnabled` only when zoomed prevents conflict with
  // swipe between pages.

  return /*#__PURE__*/_react.default.createElement(_reactNativeGestureHandler.GestureDetector, {
    gesture: gestureHandler
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: Styles.container,
    onLayout: onViewLayout
  }, /*#__PURE__*/_react.default.createElement(AnimatedScrollView, {
    horizontal: true,
    onScroll: _reactNative.Animated.event([{
      nativeEvent: {
        contentOffset: {
          x: contentOffset.animated.x
        }
      }
    }], {
      useNativeDriver: false
    }),
    ref: hScrollRef,
    scrollEnabled: isZoomed,
    scrollEventThrottle: 50,
    waitFor: _reactNative.Platform.select({
      android: gestureRef
    })
  }, /*#__PURE__*/_react.default.createElement(AnimatedScrollView, {
    onScroll: _reactNative.Animated.event([{
      nativeEvent: {
        contentOffset: {
          y: contentOffset.animated.y
        }
      }
    }], {
      useNativeDriver: false
    }),
    ref: vScrollRef,
    refreshControl: refreshControl,
    scrollEventThrottle: 50,
    waitFor: _reactNative.Platform.select({
      android: gestureRef
    })
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: Styles.row
  }, /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: {
      width: bufferSize.x
    }
  }), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: zoomStyle
  }, /*#__PURE__*/_react.default.createElement(RenderComponent, _extends({}, pdfViewProps, {
    onLoadComplete: localOnLoadComplete
  }))), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: {
      width: bufferSize.x
    }
  })), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: {
      height: bufferSize.y
    }
  })))));
}

const Styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1
  },
  row: {
    flexDirection: 'row'
  }
});
//# sourceMappingURL=ZoomPdfView.js.map